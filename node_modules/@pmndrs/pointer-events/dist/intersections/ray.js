import { Matrix4, Plane, Quaternion, Raycaster, Vector3, Vector2, } from 'three';
import { computeIntersectionWorldPlane, getDominantIntersectionIndex } from './utils.js';
import { Intersector } from './intersector.js';
import { updateAndCheckWorldTransformation } from '../utils.js';
const invertedMatrixHelper = new Matrix4();
const intersectsHelper = [];
const scaleHelper = new Vector3();
const NegZAxis = new Vector3(0, 0, -1);
const directionHelper = new Vector3();
const planeHelper = new Plane();
export class RayIntersector extends Intersector {
    space;
    options;
    raycaster = new Raycaster();
    raycasterQuaternion = new Quaternion();
    worldScale = 0;
    ready;
    constructor(space, options) {
        super();
        this.space = space;
        this.options = options;
    }
    isReady() {
        return this.ready ?? this.prepareTransformation();
    }
    prepareTransformation() {
        const spaceObject = this.space.current;
        if (spaceObject == null) {
            return (this.ready = false);
        }
        this.ready = updateAndCheckWorldTransformation(spaceObject);
        if (!this.ready) {
            return false;
        }
        spaceObject.matrixWorld.decompose(this.raycaster.ray.origin, this.raycasterQuaternion, scaleHelper);
        this.worldScale = scaleHelper.x;
        this.raycaster.ray.direction.copy(this.options?.direction ?? NegZAxis).applyQuaternion(this.raycasterQuaternion);
        return true;
    }
    intersectPointerCapture({ intersection, object }) {
        if (intersection.details.type != 'ray') {
            return undefined;
        }
        if (!this.prepareTransformation()) {
            return undefined;
        }
        computeIntersectionWorldPlane(planeHelper, intersection, object);
        const { ray } = this.raycaster;
        const pointOnFace = ray.intersectPlane(planeHelper, new Vector3()) ?? intersection.point;
        return {
            ...intersection,
            object,
            pointOnFace,
            point: ray.direction.clone().multiplyScalar(intersection.distance).add(ray.origin),
            pointerPosition: ray.origin.clone(),
            pointerQuaternion: this.raycasterQuaternion.clone(),
        };
    }
    prepareIntersection() {
        this.prepareTransformation();
    }
    executeIntersection(object, objectPointerEventsOrder) {
        if (!this.isReady()) {
            return;
        }
        object.raycast(this.raycaster, intersectsHelper);
        const index = getDominantIntersectionIndex(this.intersection, this.pointerEventsOrder, intersectsHelper, objectPointerEventsOrder, this.options);
        if (index != null) {
            this.intersection = intersectsHelper[index];
            this.pointerEventsOrder = objectPointerEventsOrder;
        }
        intersectsHelper.length = 0;
    }
    finalizeIntersection() {
        if (this.intersection == null) {
            return undefined;
        }
        if (this.options.minDistance != null && this.intersection.distance * this.worldScale < this.options.minDistance) {
            return undefined;
        }
        return Object.assign(this.intersection, {
            details: {
                type: 'ray',
            },
            pointerPosition: this.raycaster.ray.origin.clone(),
            pointerQuaternion: this.raycasterQuaternion.clone(),
            pointOnFace: this.intersection.point,
            localPoint: this.intersection.point
                .clone()
                .applyMatrix4(invertedMatrixHelper.copy(this.intersection.object.matrixWorld).invert()),
        });
    }
}
export class CameraRayIntersector extends Intersector {
    prepareTransformation;
    options;
    raycaster = new Raycaster();
    fromPosition = new Vector3();
    fromQuaternion = new Quaternion();
    coords = new Vector2();
    viewPlane = new Plane();
    constructor(prepareTransformation, options) {
        super();
        this.prepareTransformation = prepareTransformation;
        this.options = options;
    }
    isReady() {
        return true;
    }
    intersectPointerCapture({ intersection, object }, nativeEvent) {
        const details = intersection.details;
        if (details.type != 'camera-ray') {
            return undefined;
        }
        if (!this.prepareIntersection(nativeEvent)) {
            return undefined;
        }
        this.viewPlane.constant -= details.distanceViewPlane;
        //find captured intersection point by intersecting the ray to the plane of the camera
        const point = this.raycaster.ray.intersectPlane(this.viewPlane, new Vector3());
        if (point == null) {
            return undefined;
        }
        computeIntersectionWorldPlane(this.viewPlane, intersection, object);
        return {
            ...intersection,
            object,
            point,
            pointOnFace: point,
            pointerPosition: this.fromPosition.clone(),
            pointerQuaternion: this.fromQuaternion.clone(),
        };
    }
    prepareIntersection(nativeEvent) {
        const from = this.prepareTransformation(nativeEvent, this.coords);
        if (from == null) {
            return false;
        }
        from.matrixWorld.decompose(this.fromPosition, this.fromQuaternion, scaleHelper);
        from.updateWorldMatrix(true, false);
        this.raycaster.setFromCamera(this.coords, from);
        this.viewPlane.setFromNormalAndCoplanarPoint(from.getWorldDirection(directionHelper), this.raycaster.ray.origin);
        return true;
    }
    executeIntersection(object, objectPointerEventsOrder) {
        object.raycast(this.raycaster, intersectsHelper);
        const index = getDominantIntersectionIndex(this.intersection, this.pointerEventsOrder, intersectsHelper, objectPointerEventsOrder, this.options);
        if (index != null) {
            this.intersection = intersectsHelper[index];
            this.pointerEventsOrder = objectPointerEventsOrder;
        }
        intersectsHelper.length = 0;
    }
    finalizeIntersection() {
        if (this.intersection == null) {
            return undefined;
        }
        invertedMatrixHelper.copy(this.intersection.object.matrixWorld).invert();
        return Object.assign(this.intersection, {
            details: {
                type: 'camera-ray',
                distanceViewPlane: this.viewPlane.distanceToPoint(this.intersection.point),
            },
            pointOnFace: this.intersection.point,
            pointerPosition: this.fromPosition.clone(),
            pointerQuaternion: this.fromQuaternion.clone(),
            localPoint: this.intersection.point.clone().applyMatrix4(invertedMatrixHelper),
        });
    }
}
